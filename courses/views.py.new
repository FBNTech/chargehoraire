from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import ListView, CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy
from django.contrib import messages
from .models import Course
from .forms import CourseForm
import pandas as pd
from django.http import JsonResponse
from django.db.models import Q
from django.views.decorators.csrf import csrf_exempt
import logging
import os
import tempfile

logger = logging.getLogger(__name__)

# Create your views here.

class CourseListView(ListView):
    model = Course
    template_name = 'courses/course_list.html'
    context_object_name = 'courses'
    
    def get_queryset(self):
        queryset = Course.objects.all()
        search_query = self.request.GET.get('search')
        if search_query:
            queryset = queryset.filter(
                Q(code_ue__icontains=search_query) |
                Q(intitule_ue__icontains=search_query) |
                Q(intitule_ec__icontains=search_query) |
                Q(classe__icontains=search_query) |
                Q(semestre__icontains=search_query) |
                Q(departement__icontains=search_query)
            )
        return queryset

class CourseCreateView(CreateView):
    model = Course
    form_class = CourseForm
    template_name = 'courses/course_form.html'
    success_url = reverse_lazy('courses:list')

    def form_valid(self, form):
        messages.success(self.request, 'Cours ajouté avec succès!')
        return super().form_valid(form)

class CourseUpdateView(UpdateView):
    model = Course
    form_class = CourseForm
    template_name = 'courses/course_form.html'
    success_url = reverse_lazy('courses:list')

    def form_valid(self, form):
        messages.success(self.request, 'Cours modifié avec succès!')
        return super().form_valid(form)

class CourseDeleteView(DeleteView):
    model = Course
    success_url = reverse_lazy('courses:list')
    template_name = 'courses/course_confirm_delete.html'

    def delete(self, request, *args, **kwargs):
        course = self.get_object()
        course_name = course.code_ue + ' - ' + course.intitule_ue
        messages.success(request, f"Le cours {course_name} a été supprimé avec succès.")
        return super().delete(request, *args, **kwargs)

@csrf_exempt
def import_excel(request):
    if request.method == 'POST':
        try:
            excel_file = request.FILES.get('excel_file')
            if not excel_file:
                return JsonResponse({'error': 'Aucun fichier sélectionné'}, status=400)

            # Créer un dossier temporaire s'il n'existe pas
            temp_dir = os.path.join(tempfile.gettempdir(), 'excel_imports')
            os.makedirs(temp_dir, exist_ok=True)
            
            # Sauvegarder le fichier temporairement
            temp_path = os.path.join(temp_dir, excel_file.name)
            with open(temp_path, 'wb+') as destination:
                for chunk in excel_file.chunks():
                    destination.write(chunk)

            # Lire le fichier Excel
            df = pd.read_excel(temp_path)
            
            # Normaliser les noms de colonnes
            df.columns = [col.strip().lower().replace(' ', '_') for col in df.columns]
            
            # Vérifier les colonnes requises
            required_columns = ['code_ue', 'intitule_ue', 'intitule_ec', 'credit', 'cmi', 'td_tp', 'classe', 'semestre', 'departement']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                os.remove(temp_path)  # Nettoyer le fichier temporaire
                return JsonResponse({
                    'error': f'Colonnes manquantes : {", ".join(missing_columns)}'
                }, status=400)

            # Envoyer le nombre total de lignes et le chemin du fichier
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'total': len(df),
                    'status': 'starting',
                    'temp_file': temp_path
                })

        except Exception as e:
            # Nettoyer en cas d'erreur
            if 'temp_path' in locals():
                os.remove(temp_path)
            return JsonResponse({
                'error': f"Erreur lors de l'import: {str(e)}"
            }, status=500)

    elif request.method == 'GET' and request.headers.get('X-Progress'):
        try:
            current_progress = int(request.GET.get('current', 0))
            total = int(request.GET.get('total', 0))
            temp_path = request.GET.get('temp_file')
            
            if not temp_path or not os.path.exists(temp_path) or current_progress >= total:
                return JsonResponse({'error': 'Fichier temporaire non trouvé ou paramètres invalides'}, status=400)

            # Lire le fichier Excel
            df = pd.read_excel(temp_path)
            df.columns = [col.strip().lower().replace(' ', '_') for col in df.columns]
            
            # Traiter le prochain lot de lignes (5 lignes à la fois)
            batch_size = 5
            end_index = min(current_progress + batch_size, total)
            
            for index in range(current_progress, end_index):
                row = df.iloc[index]
                try:
                    course_data = {
                        'code_ue': str(row['code_ue']).strip(),
                        'intitule_ue': str(row['intitule_ue']).strip(),
                        'intitule_ec': str(row['intitule_ec']).strip(),
                        'credit': int(row['credit']),
                        'cmi': int(row['cmi']),
                        'td_tp': int(row['td_tp']),
                        'classe': str(row['classe']).strip(),
                        'semestre': str(row['semestre']).strip(),
                        'departement': str(row['departement']).strip()
                    }

                    Course.objects.update_or_create(
                        code_ue=course_data['code_ue'],
                        defaults=course_data
                    )

                except Exception as e:
                    # Nettoyer en cas d'erreur
                    os.remove(temp_path)
                    return JsonResponse({
                        'error': f"Erreur à la ligne {index + 1}: {str(e)}"
                    }, status=500)

            progress = (end_index / total) * 100
            
            # Si c'est la dernière itération, supprimer le fichier temporaire
            if end_index >= total:
                os.remove(temp_path)
                return JsonResponse({
                    'current': end_index,
                    'total': total,
                    'progress': 100,
                    'status': 'completed',
                    'message': f"{end_index} cours importés avec succès!"
                })
            
            return JsonResponse({
                'current': end_index,
                'total': total,
                'progress': progress,
                'status': 'processing',
                'temp_file': temp_path
            })

        except Exception as e:
            # Nettoyer en cas d'erreur
            if 'temp_path' in locals():
                os.remove(temp_path)
            return JsonResponse({
                'error': f"Erreur lors du traitement: {str(e)}"
            }, status=500)

def import_courses(request):
    """Importe des cours à partir d'un fichier Excel."""
    if request.method == 'POST' and 'file' in request.FILES:
        try:
            file = request.FILES['file']
            df = pd.read_excel(file)
            
            # Normaliser les noms de colonnes
            df.columns = [col.strip().lower().replace(' ', '_') for col in df.columns]
            
            # Vérifier les colonnes requises
            required_columns = ['code_ue', 'intitule_ue', 'intitule_ec', 'credit', 'cmi', 'td_tp', 'classe', 'semestre', 'departement']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                messages.error(request, f'Colonnes manquantes dans le fichier: {", ".join(missing_columns)}')
                return redirect('courses:list')
            
            # Compter les cours ajoutés ou mis à jour
            added = 0
            updated = 0
            
            for _, row in df.iterrows():
                course_data = {
                    'code_ue': str(row['code_ue']).strip(),
                    'intitule_ue': str(row['intitule_ue']).strip(),
                    'intitule_ec': str(row['intitule_ec']).strip(),
                    'credit': int(row['credit']),
                    'cmi': int(row['cmi']),
                    'td_tp': int(row['td_tp']),
                    'classe': str(row['classe']).strip(),
                    'semestre': str(row['semestre']).strip(),
                    'departement': str(row['departement']).strip()
                }
                
                # Mettre à jour ou créer le cours
                course, created = Course.objects.update_or_create(
                    code_ue=course_data['code_ue'],
                    defaults=course_data
                )
                
                if created:
                    added += 1
                else:
                    updated += 1
            
            messages.success(request, f'Import terminé : {added} cours ajoutés, {updated} cours mis à jour.')
        
        except Exception as e:
            messages.error(request, f'Erreur lors de l\'import : {str(e)}')
        
        return redirect('courses:list')
    
    return render(request, 'courses/course_list.html')
